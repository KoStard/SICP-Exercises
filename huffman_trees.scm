(define (make_leaf symbol weight)
    (list 'leaf symbol weight)
)

(define (leaf? object)
    (eq? (car object) 'leaf)
)

(define (symbol_leaf x) (cadr x))
(define (weight_leaf x) (caddr x))

(define (make_code_tree left right)
    (list left right 
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right)))
)

(define (left_branch tree) (car tree))
(define (right_branch tree) (cadr tree))
(define (symbols tree) 
    (if (leaf? tree)
        (list (symbol_leaf tree))
        (caddr tree)
    )
)
(define (weight tree) 
    (if (leaf? tree)
        (weight_leaf tree)
        (cadddr tree)
    )
)

(define (decode bits tree)
    (define (decode_internal bits current_branch)
        (if (leaf? current_branch)
            (if (null? bits)
                (list (symbol_leaf current_branch))
                (cons (symbol_leaf current_branch) (decode_internal bits tree))
            )
            (if (null? bits)
                '()
                (let ((current_bit (car bits)) (remaining_bits (cdr bits)))
                    (cond ((= current_bit 0) (decode_internal remaining_bits (left_branch current_branch)))
                        ((= current_bit 1) (decode_internal remaining_bits (right_branch current_branch)))
                        (else (error "bad bit -- DECODE" current_bit))
                    )
                )
            )
        )
    )
    (decode_internal bits tree)
)

;;; Implementing adjoin_set for using while generating Huffman trees
(define (adjoin_set x set)
    (cond 
        ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set) (adjoin_set x (cdr set))))
    )
)

(define (make_leaf_set pairs)
    (if (null? pairs)
        '()
        (let ((pair (car pairs)))
            (adjoin_set (make_leaf (car pair) (cadr pair))
                (make_leaf_set (cdr pairs))
            )
        )
    )
)